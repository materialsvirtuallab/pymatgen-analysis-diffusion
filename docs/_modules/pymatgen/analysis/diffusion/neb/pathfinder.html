
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymatgen.analysis.diffusion.neb.pathfinder &#8212; pymatgen-diffusion 2021.3.5 documentation</title>
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/flasky.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../../" src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />

   
  
  <link media="only screen and (max-device-width: 480px)" href="../../../../../_static/small_flask.css" type= "text/css" rel="stylesheet" />
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33990148-1']);
  _gaq.push(['_trackPageview']);
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../../../index.html">pymatgen-diffusion 2021.3.5 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../../../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">pymatgen.analysis.diffusion.neb.pathfinder</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pymatgen.analysis.diffusion.neb.pathfinder</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="c1"># Copyright (c) Materials Virtual Lab.</span>
<span class="c1"># Distributed under the terms of the BSD License.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Algorithms for NEB migration path analysis.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pymatgen.core</span> <span class="kn">import</span> <span class="n">Site</span>
<span class="kn">from</span> <span class="nn">pymatgen.core</span> <span class="kn">import</span> <span class="n">PeriodicSite</span><span class="p">,</span> <span class="n">Structure</span>
<span class="kn">from</span> <span class="nn">pymatgen.core.periodic_table</span> <span class="kn">import</span> <span class="n">get_el_sp</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.analyzer</span> <span class="kn">import</span> <span class="n">SpacegroupAnalyzer</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Iek-Heng Chu&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;1.0&quot;</span>
<span class="n">__date__</span> <span class="o">=</span> <span class="s2">&quot;March 14, 2017&quot;</span>


<span class="c1"># TODO: (1) ipython notebook example files, unittests</span>
<span class="kn">from</span> <span class="nn">pymatgen.symmetry.structure</span> <span class="kn">import</span> <span class="n">SymmetrizedStructure</span>

<span class="kn">from</span> <span class="nn">pymatgen.analysis.diffusion.utils.supercells</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_sc_fromstruct</span><span class="p">,</span>
    <span class="n">get_start_end_structures</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="IDPPSolver"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.IDPPSolver">[docs]</a><span class="k">class</span> <span class="nc">IDPPSolver</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A solver using image dependent pair potential (IDPP) algo to get an improved</span>
<span class="sd">    initial NEB path. For more details about this algo, please refer to</span>
<span class="sd">    Smidstrup et al., J. Chem. Phys. 140, 214106 (2014).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">structures</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialization.</span>

<span class="sd">        Args:</span>
<span class="sd">            structures (list of pmg_structure) : Initial guess of the NEB path</span>
<span class="sd">                (including initial and final end-point structures).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">latt</span> <span class="o">=</span> <span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lattice</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_sites</span>
        <span class="n">nimages</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="n">target_dists</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Initial guess of the path (in Cartesian coordinates) used in the IDPP</span>
        <span class="c1"># algo.</span>
        <span class="n">init_coords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Construct the set of target distance matrices via linear interpolation</span>
        <span class="c1"># between those of end-point structures.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Interpolated distance matrices</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance_matrix</span> <span class="o">+</span> <span class="n">i</span> <span class="o">/</span> <span class="p">(</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                <span class="n">structures</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">distance_matrix</span> <span class="o">-</span> <span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance_matrix</span>
            <span class="p">)</span>

            <span class="n">target_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="n">target_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">target_dists</span><span class="p">)</span>

        <span class="c1"># Set of translational vector matrices (anti-symmetric) for the images.</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nimages</span><span class="p">,</span> <span class="n">natoms</span><span class="p">,</span> <span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># A set of weight functions. It is set as 1/d^4 for each image. Here,</span>
        <span class="c1"># we take d as the average of the target distance matrix and the actual</span>
        <span class="c1"># distance matrix.</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">target_dists</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimages</span><span class="p">):</span>
            <span class="n">avg_dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_dists</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">+</span> <span class="n">structures</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">weights</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">avg_dist</span> <span class="o">**</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">natoms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ni</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">)):</span>
            <span class="n">frac_coords</span> <span class="o">=</span> <span class="n">structures</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span>
            <span class="n">init_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">latt</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">ni</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">natoms</span><span class="p">):</span>
                    <span class="n">img</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">get_distance_and_image</span><span class="p">(</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">structures</span><span class="p">[</span><span class="n">ni</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">translations</span><span class="p">[</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">latt</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
                    <span class="n">translations</span><span class="p">[</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">latt</span><span class="o">.</span><span class="n">get_cartesian_coords</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">init_coords</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">translations</span> <span class="o">=</span> <span class="n">translations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structures</span> <span class="o">=</span> <span class="n">structures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_dists</span> <span class="o">=</span> <span class="n">target_dists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nimages</span> <span class="o">=</span> <span class="n">nimages</span>

<div class="viewcode-block" id="IDPPSolver.run"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.IDPPSolver.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
        <span class="n">tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">gtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span>
        <span class="n">step_size</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">max_disp</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">spring_const</span><span class="o">=</span><span class="mf">5.0</span><span class="p">,</span>
        <span class="n">species</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform iterative minimization of the set of objective functions in an</span>
<span class="sd">        NEB-like manner. In each iteration, the total force matrix for each</span>
<span class="sd">        image is constructed, which comprises both the spring forces and true</span>
<span class="sd">        forces. For more details about the NEB approach, please see the</span>
<span class="sd">        references, e.g. Henkelman et al., J. Chem. Phys. 113, 9901 (2000).</span>

<span class="sd">        Args:</span>
<span class="sd">            maxiter (int): Maximum number of iterations in the minimization</span>
<span class="sd">                process.</span>
<span class="sd">            tol (float): Tolerance of the change of objective functions between</span>
<span class="sd">                consecutive steps.</span>
<span class="sd">            gtol (float): Tolerance of maximum force component (absolute value).</span>
<span class="sd">            step_size (float): Step size associated with the displacement of</span>
<span class="sd">                the atoms during the minimization process.</span>
<span class="sd">            max_disp (float): Maximum allowed atomic displacement in each</span>
<span class="sd">                iteration.</span>
<span class="sd">            spring_const (float): A virtual spring constant used in the NEB-like</span>
<span class="sd">                        relaxation process that yields so-called IDPP path.</span>
<span class="sd">            species (list of string): If provided, only those given species are</span>
<span class="sd">                allowed to move. The atomic positions of other species are</span>
<span class="sd">                obtained via regular linear interpolation approach.</span>

<span class="sd">        Returns:</span>
<span class="sd">            [Structure] Complete IDPP path (including end-point structures)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">old_funcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">idpp_structures</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">species</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_el_sp</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">species</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">site</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span> <span class="ow">in</span> <span class="n">species</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The given species are not in the system!&quot;</span><span class="p">)</span>

        <span class="c1"># Iterative minimization</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
            <span class="c1"># Get the sets of objective functions, true and total force</span>
            <span class="c1"># matrices.</span>
            <span class="n">funcs</span><span class="p">,</span> <span class="n">true_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_funcs_and_forces</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">tot_forces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_total_forces</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">true_forces</span><span class="p">,</span> <span class="n">spring_const</span><span class="o">=</span><span class="n">spring_const</span><span class="p">)</span>

            <span class="c1"># Each atom is allowed to move up to max_disp</span>
            <span class="n">disp_mat</span> <span class="o">=</span> <span class="n">step_size</span> <span class="o">*</span> <span class="n">tot_forces</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">disp_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">disp_mat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_disp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">disp_mat</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_disp</span><span class="p">,</span> <span class="n">disp_mat</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">disp_mat</span>

            <span class="n">max_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tot_forces</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">tot_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">old_funcs</span> <span class="o">-</span> <span class="n">funcs</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">tot_res</span> <span class="o">&lt;</span> <span class="n">tol</span> <span class="ow">and</span> <span class="n">max_force</span> <span class="o">&lt;</span> <span class="n">gtol</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">old_funcs</span> <span class="o">=</span> <span class="n">funcs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Maximum iteration number is reached without convergence!&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nimages</span><span class="p">):</span>
            <span class="c1"># generate the improved image structure</span>
            <span class="n">new_sites</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">site</span><span class="p">,</span> <span class="n">cart_coords</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="n">new_site</span> <span class="o">=</span> <span class="n">PeriodicSite</span><span class="p">(</span>
                    <span class="n">site</span><span class="o">.</span><span class="n">species</span><span class="p">,</span>
                    <span class="n">coords</span><span class="o">=</span><span class="n">cart_coords</span><span class="p">,</span>
                    <span class="n">lattice</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span>
                    <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">properties</span><span class="o">=</span><span class="n">site</span><span class="o">.</span><span class="n">properties</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">new_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_site</span><span class="p">)</span>

            <span class="n">idpp_structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">new_sites</span><span class="p">))</span>

        <span class="c1"># Also include end-point structure.</span>
        <span class="n">idpp_structures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structures</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">idpp_structures</span></div>

<div class="viewcode-block" id="IDPPSolver.from_endpoints"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.IDPPSolver.from_endpoints">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_endpoints</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">endpoints</span><span class="p">,</span> <span class="n">nimages</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sort_tol</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A class method that starts with end-point structures instead. The</span>
<span class="sd">        initial guess for the IDPP algo is then constructed using linear</span>
<span class="sd">        interpolation.</span>

<span class="sd">        Args:</span>
<span class="sd">            endpoints (list of Structure objects): The two end-point structures.</span>
<span class="sd">            nimages (int): Number of images between the two end-points.</span>
<span class="sd">            sort_tol (float): Distance tolerance (in Angstrom) used to match the</span>
<span class="sd">                atomic indices between start and end structures. Need</span>
<span class="sd">                to increase the value in some cases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">images</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">endpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">autosort_tol</span><span class="o">=</span><span class="n">sort_tol</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;Unable to reliably match structures &quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Auto sorting is turned off because it is unable&quot;</span> <span class="s2">&quot; to match the end-point structures!&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">images</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">endpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">autosort_tol</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">IDPPSolver</span><span class="p">(</span><span class="n">images</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_funcs_and_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the set of objective functions as well as their gradients,</span>
<span class="sd">        i.e. &quot;effective true forces&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">funcs_prime</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">translations</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span>
        <span class="n">target_dists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_dists</span>

        <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">trans</span><span class="p">[</span><span class="n">ni</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">natoms</span><span class="p">)]</span>

            <span class="n">trial_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="p">(</span><span class="n">trial_dist</span> <span class="o">-</span> <span class="n">target_dists</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">trial_dist</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">natoms</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

            <span class="c1"># Objective function</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">trial_dist</span> <span class="o">-</span> <span class="n">target_dists</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">weights</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span>

            <span class="c1"># &quot;True force&quot; derived from the objective function.</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">aux</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">funcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="n">funcs_prime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>

        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">funcs</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">funcs_prime</span><span class="p">)</span>

<div class="viewcode-block" id="IDPPSolver.get_unit_vector"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.IDPPSolver.get_unit_vector">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_unit_vector</span><span class="p">(</span><span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the unit vector of a vector.</span>
<span class="sd">        Args:</span>
<span class="sd">            vec: Vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vec</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vec</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_total_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">true_forces</span><span class="p">,</span> <span class="n">spring_const</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the total force on each image structure, which is equal to</span>
<span class="sd">        the spring force along the tangent + true force perpendicular to the</span>
<span class="sd">        tangent. Note that the spring force is the modified version in the</span>
<span class="sd">        literature (e.g. Henkelman et al., J. Chem. Phys. 113, 9901 (2000)).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">total_forces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">natoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">true_forces</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">vec1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ni</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ni</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">vec2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">ni</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># Local tangent</span>
            <span class="n">tangent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_vector</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_vector</span><span class="p">(</span><span class="n">vec2</span><span class="p">)</span>
            <span class="n">tangent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_unit_vector</span><span class="p">(</span><span class="n">tangent</span><span class="p">)</span>

            <span class="c1"># Spring force</span>
            <span class="n">spring_force</span> <span class="o">=</span> <span class="n">spring_const</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">vec2</span><span class="p">))</span> <span class="o">*</span> <span class="n">tangent</span>

            <span class="c1"># Total force</span>
            <span class="n">flat_ft</span> <span class="o">=</span> <span class="n">true_forces</span><span class="p">[</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">total_force</span> <span class="o">=</span> <span class="n">true_forces</span><span class="p">[</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">spring_force</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">flat_ft</span><span class="p">,</span> <span class="n">tangent</span><span class="p">)</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">total_forces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_force</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">total_forces</span><span class="p">)</span></div>


<div class="viewcode-block" id="MigrationHop"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.MigrationHop">[docs]</a><span class="k">class</span> <span class="nc">MigrationHop</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A convenience container representing a migration path.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">isite</span><span class="p">:</span> <span class="n">Site</span><span class="p">,</span>
        <span class="n">esite</span><span class="p">:</span> <span class="n">Site</span><span class="p">,</span>
        <span class="n">symm_structure</span><span class="p">:</span> <span class="n">SymmetrizedStructure</span><span class="p">,</span>
        <span class="n">symprec</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            isite: Initial site</span>
<span class="sd">            esite: End site</span>
<span class="sd">            symm_structure: SymmetrizedStructure</span>
<span class="sd">            symprec: used to determine equivalence</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">isite</span> <span class="o">=</span> <span class="n">isite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">esite</span> <span class="o">=</span> <span class="n">esite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span> <span class="o">=</span> <span class="n">symm_structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symprec</span> <span class="o">=</span> <span class="n">symprec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">msite</span> <span class="o">=</span> <span class="n">PeriodicSite</span><span class="p">(</span><span class="n">esite</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span> <span class="p">(</span><span class="n">isite</span><span class="o">.</span><span class="n">frac_coords</span> <span class="o">+</span> <span class="n">esite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">esite</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">spacegroup</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">are_symmetrically_equivalent</span><span class="p">([</span><span class="n">isite</span><span class="p">],</span> <span class="p">[</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">are_symmetrically_equivalent</span><span class="p">([</span><span class="n">esite</span><span class="p">],</span> <span class="p">[</span><span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span> <span class="o">=</span> <span class="n">i</span>

        <span class="c1"># if no index was identified then loop over each site until something is found</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">itr_site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">are_symmetrically_equivalent</span><span class="p">([</span><span class="n">isite</span><span class="p">],</span> <span class="p">[</span><span class="n">itr_site</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sites</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">itr_site</span> <span class="ow">in</span> <span class="n">sites</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sg</span><span class="o">.</span><span class="n">are_symmetrically_equivalent</span><span class="p">([</span><span class="n">esite</span><span class="p">],</span> <span class="p">[</span><span class="n">itr_site</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No symmetrically equivalent site was found for </span><span class="si">{</span><span class="n">isite</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No symmetrically equivalent site was found for </span><span class="si">{</span><span class="n">esite</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;Path of </span><span class="si">%.4f</span><span class="s2"> A from </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">] &quot;</span>
            <span class="s2">&quot;(ind: </span><span class="si">%d</span><span class="s2">, Wyckoff: </span><span class="si">%s</span><span class="s2">) to </span><span class="si">%s</span><span class="s2"> [</span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">, </span><span class="si">%.3f</span><span class="s2">] (ind: </span><span class="si">%d</span><span class="s2">, Wyckoff: </span><span class="si">%s</span><span class="s2">)&quot;</span>
            <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">length</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">wyckoff_symbols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iindex</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="o">.</span><span class="n">specie</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">wyckoff_symbols</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eindex</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            (float) Length of migration path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">coords</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iindex</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eindex</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">symm_structure</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">spacegroup</span><span class="o">.</span><span class="n">are_symmetrically_equivalent</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">msite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="p">),</span>
            <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">isite</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">msite</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">esite</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symprec</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="MigrationHop.get_structures"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.MigrationHop.get_structures">[docs]</a>    <span class="k">def</span> <span class="nf">get_structures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nimages</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">vac_mode</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">idpp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">idpp_kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate structures for NEB calculation.</span>

<span class="sd">        Args:</span>
<span class="sd">            nimages (int): Defaults to 5. Number of NEB images. Total number of</span>
<span class="sd">                structures returned in nimages+2.</span>
<span class="sd">            vac_mode (bool): Defaults to True. In vac_mode, a vacancy diffusion</span>
<span class="sd">                mechanism is assumed. The initial and end sites of the path</span>
<span class="sd">                are assumed to be the initial and ending positions of the</span>
<span class="sd">                vacancies. If vac_mode is False, an interstitial mechanism is</span>
<span class="sd">                assumed. The initial and ending positions are assumed to be</span>
<span class="sd">                the initial and ending positions of the interstitial, and all</span>
<span class="sd">                other sites of the same specie are removed. E.g., if NEBPaths</span>
<span class="sd">                were obtained using a Li4Fe4P4O16 structure, vac_mode=True would</span>
<span class="sd">                generate structures with formula Li3Fe4P4O16, while</span>
<span class="sd">                vac_mode=False would generate structures with formula</span>
<span class="sd">                LiFe4P4O16.</span>
<span class="sd">            idpp (bool): Defaults to False. If True, the generated structures</span>
<span class="sd">                will be run through the IDPPSolver to generate a better guess</span>
<span class="sd">                for the minimum energy path.</span>
<span class="sd">            \*\*idpp_kwargs: Passthrough kwargs for the IDPPSolver.run.</span>

<span class="sd">        Returns:</span>
<span class="sd">            [Structure] Note that the first site of each structure is always</span>
<span class="sd">            the migrating ion. This makes it easier to perform subsequent</span>
<span class="sd">            analysis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">migrating_specie_sites</span><span class="p">,</span> <span class="n">other_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_migrating_and_other_sites</span><span class="p">(</span><span class="n">vac_mode</span><span class="p">)</span>

        <span class="n">start_structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="p">]</span> <span class="o">+</span> <span class="n">migrating_specie_sites</span> <span class="o">+</span> <span class="n">other_sites</span><span class="p">)</span>
        <span class="n">end_structure</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="p">]</span> <span class="o">+</span> <span class="n">migrating_specie_sites</span> <span class="o">+</span> <span class="n">other_sites</span><span class="p">)</span>

        <span class="n">structures</span> <span class="o">=</span> <span class="n">start_structure</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">end_structure</span><span class="p">,</span> <span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idpp</span><span class="p">:</span>
            <span class="n">solver</span> <span class="o">=</span> <span class="n">IDPPSolver</span><span class="p">(</span><span class="n">structures</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="o">**</span><span class="n">idpp_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">structures</span></div>

    <span class="k">def</span> <span class="nf">_split_migrating_and_other_sites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vac_mode</span><span class="p">):</span>
        <span class="n">migrating_specie_sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other_sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">site</span><span class="o">.</span><span class="n">specie</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">specie</span><span class="p">:</span>
                <span class="n">other_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">vac_mode</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">migrating_specie_sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">migrating_specie_sites</span><span class="p">,</span> <span class="n">other_sites</span>

<div class="viewcode-block" id="MigrationHop.get_sc_structures"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.MigrationHop.get_sc_structures">[docs]</a>    <span class="k">def</span> <span class="nf">get_sc_structures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vac_mode</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">min_atoms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
        <span class="n">max_atoms</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">240</span><span class="p">,</span>
        <span class="n">min_length</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Structure</span><span class="p">,</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">Structure</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct supercells that represents the start and end positions for migration analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">            vac_mode: If true simulate vacancy diffusion.</span>
<span class="sd">            max_atoms: Maximum number of atoms allowed in the supercell.</span>
<span class="sd">            min_atoms: Minimum number of atoms allowed in the supercell.</span>
<span class="sd">            min_length: Minimum length of the smallest supercell lattice vector.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Start, End, Base Structures.</span>

<span class="sd">            If not vacancy mode, the base structure is just the host lattice.</span>
<span class="sd">            If in vacancy mode, the base structure is the fully intercalated structure</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">migrating_specie_sites</span><span class="p">,</span> <span class="n">other_sites</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_migrating_and_other_sites</span><span class="p">(</span><span class="n">vac_mode</span><span class="p">)</span>
        <span class="n">base_struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">other_sites</span><span class="p">)</span>
        <span class="n">sc_mat</span> <span class="o">=</span> <span class="n">get_sc_fromstruct</span><span class="p">(</span>
            <span class="n">base_struct</span><span class="o">=</span><span class="n">base_struct</span><span class="p">,</span>
            <span class="n">min_atoms</span><span class="o">=</span><span class="n">min_atoms</span><span class="p">,</span>
            <span class="n">max_atoms</span><span class="o">=</span><span class="n">max_atoms</span><span class="p">,</span>
            <span class="n">min_length</span><span class="o">=</span><span class="n">min_length</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">start_struct</span><span class="p">,</span> <span class="n">end_struct</span><span class="p">,</span> <span class="n">base_sc</span> <span class="o">=</span> <span class="n">get_start_end_structures</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">isite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">esite</span><span class="p">,</span> <span class="n">base_struct</span><span class="p">,</span> <span class="n">sc_mat</span><span class="p">,</span> <span class="n">vac_mode</span><span class="o">=</span><span class="n">vac_mode</span>  <span class="c1"># type: ignore</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">start_struct</span><span class="p">,</span> <span class="n">end_struct</span><span class="p">,</span> <span class="n">base_sc</span></div>

<div class="viewcode-block" id="MigrationHop.write_path"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.MigrationHop.write_path">[docs]</a>    <span class="k">def</span> <span class="nf">write_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the path to a file for easy viewing.</span>

<span class="sd">        Args:</span>
<span class="sd">            fname (str): File name.</span>
<span class="sd">            \*\*kwargs: Kwargs supported by NEBPath.get_structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_structures</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">sites</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span>
        <span class="n">st</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DistinctPathFinder"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.DistinctPathFinder">[docs]</a><span class="k">class</span> <span class="nc">DistinctPathFinder</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines symmetrically distinct paths between existing sites.</span>
<span class="sd">    The path info can then be used to set up either vacancy or interstitial</span>
<span class="sd">    diffusion (assuming site positions are known). Note that this works mainly</span>
<span class="sd">    for atomic mechanism, and does not work for correlated migration.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">structure</span><span class="p">,</span>
        <span class="n">migrating_specie</span><span class="p">,</span>
        <span class="n">max_path_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">symprec</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">perc_mode</span><span class="o">=</span><span class="s2">&quot;&gt;1d&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            structure: Input structure that contains all sites.</span>
<span class="sd">            migrating_specie (Specie-like): The specie that migrates. E.g.,</span>
<span class="sd">                &quot;Li&quot;.</span>
<span class="sd">            max_path_length (float): Maximum length of NEB path in the unit</span>
<span class="sd">                of Angstrom. Defaults to None, which means you are setting the</span>
<span class="sd">                value to the min cutoff until finding 1D or &gt;1D percolating paths.</span>
<span class="sd">            symprec (float): Symmetry precision to determine equivalence.</span>
<span class="sd">            perc_mode(str): The percolating type. Default to &quot;&gt;1d&quot;, because usually</span>
<span class="sd">                it is used to find possible NEB paths to form percolating networks.</span>
<span class="sd">                If you just want to check the min 1D percolation, set it to &quot;1d&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">structure</span> <span class="o">=</span> <span class="n">structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">migrating_specie</span> <span class="o">=</span> <span class="n">get_el_sp</span><span class="p">(</span><span class="n">migrating_specie</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symprec</span> <span class="o">=</span> <span class="n">symprec</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">SpacegroupAnalyzer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">structure</span><span class="p">,</span> <span class="n">symprec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symprec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">get_symmetrized_structure</span><span class="p">()</span>

        <span class="n">junc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">distance_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">max_r</span> <span class="o">=</span> <span class="n">max_path_length</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">structure</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">abc</span><span class="p">)</span>
        <span class="n">junc_cutoff</span> <span class="o">=</span> <span class="n">max_r</span>
        <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrating_specie</span><span class="p">:</span>
                <span class="n">site0</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">max_r</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">nn</span><span class="p">:</span> <span class="n">nn</span><span class="o">.</span><span class="n">nn_distance</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">nn</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrating_specie</span><span class="p">:</span>
                        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">nn_distance</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">junc</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">distance_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span>
        <span class="c1"># Avoid isolated atoms (# of neighbors &lt; 2)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">distance_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">len</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">path_cutoff</span> <span class="o">=</span> <span class="n">max_r</span>
        <span class="c1"># We define junction as atoms have at least three paths including</span>
        <span class="c1"># equivalent ones.</span>
        <span class="k">elif</span> <span class="n">junc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">path_cutoff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">distance_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># distance_list are sorted as [[a0,a1,a2],[b0,b1,b2],[c0,c1,c2],...]</span>
            <span class="c1"># in which a0&lt;a1&lt;a2,b0&lt;b1&lt;b2,...</span>
            <span class="c1"># path_cutoff = max(a1,b1,c1,...), junc_cutoff=min(a2,b2,c2)</span>
            <span class="n">path_cutoff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">distance_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">junc_distance_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">distance_list</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">]</span>
            <span class="n">junc_cutoff</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">junc_distance_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">max_path_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">perc_mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;1d&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_path_length</span> <span class="o">=</span> <span class="n">path_cutoff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">max_path_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">junc_cutoff</span><span class="p">,</span> <span class="n">path_cutoff</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_path_length</span> <span class="o">=</span> <span class="n">max_path_length</span>

<div class="viewcode-block" id="DistinctPathFinder.get_paths"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.DistinctPathFinder.get_paths">[docs]</a>    <span class="k">def</span> <span class="nf">get_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            [MigrationHop] All distinct migration paths.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sites</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">equivalent_sites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrating_specie</span><span class="p">:</span>
                <span class="n">site0</span> <span class="o">=</span> <span class="n">sites</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">nn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="o">.</span><span class="n">get_neighbors</span><span class="p">(</span><span class="n">site0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_path_length</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">nn</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">migrating_specie</span><span class="p">:</span>
                        <span class="n">path</span> <span class="o">=</span> <span class="n">MigrationHop</span><span class="p">(</span><span class="n">site0</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_structure</span><span class="p">)</span>
                        <span class="n">paths</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">length</span><span class="p">)</span></div>

<div class="viewcode-block" id="DistinctPathFinder.write_all_paths"><a class="viewcode-back" href="../../../../../pymatgen.analysis.diffusion.neb.pathfinder.html#pymatgen.analysis.diffusion.neb.pathfinder.DistinctPathFinder.write_all_paths">[docs]</a>    <span class="k">def</span> <span class="nf">write_all_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">nimages</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a file containing all paths, using hydrogen as a placeholder for</span>
<span class="sd">        the images. H is chosen as it is the smallest atom. This is extremely</span>
<span class="sd">        useful for path visualization in a standard software like VESTA.</span>

<span class="sd">        Args:</span>
<span class="sd">            fname (str): Filename</span>
<span class="sd">            nimages (int): Number of images per path.</span>
<span class="sd">            \*\*kwargs: Passthrough kwargs to path.get_structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sites</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_paths</span><span class="p">():</span>
            <span class="n">structures</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">get_structures</span><span class="p">(</span><span class="n">nimages</span><span class="o">=</span><span class="n">nimages</span><span class="p">,</span> <span class="n">species</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">migrating_specie</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">structures</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">structures</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">sites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">PeriodicSite</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frac_coords</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">lattice</span><span class="p">))</span>
        <span class="n">sites</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">structures</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sites</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">Structure</span><span class="o">.</span><span class="n">from_sites</span><span class="p">(</span><span class="n">sites</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer">
      &copy; Copyright 2016, Materials Virtual Lab.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script type="text/javascript">
  (function() {
    var ga = document.createElement('script');
    ga.src = ('https:' == document.location.protocol ?
              'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    ga.setAttribute('async', 'true');
    document.documentElement.firstChild.appendChild(ga);
  })();
</script>
</div>

  </body>
</html>